import Smt
import Lean
import Veil.SMT.Main
import Veil.Util.Tactic
import Veil.Tactic.Main
import Veil.Util.TermSimp
import Auto.Solver.SMT
import Auto

open Lean hiding Command Declaration

/-- A version of `Auto.IR.SMT.processSuggestedName` that assumes
`name` arguments are unique. We use this to "reverse-engineer" what
names our indicator variables will have in the SMT-LIB generated by Lean Auto,
under the assumption that they have unique names (which is very likely true). -/
def getLeanAutoNameFor (name : String) : CoreM String := do
    let mut preName := name.map (fun c => if allowed c then c else '_')
    if preName.all (fun c => c == '_') then
      preName := "pl_" ++ preName
    if preName.back.isDigit then
      preName := preName ++ "_"
    -- If the name has not actually been used before as an argument to
    -- `processSuggestedName`, this will in fact be its name in the SMT-LIB.
    return "_" ++ preName
  where
    allowed (c : Char) :=
      let allowedStr : String :=
        "~!@$%^&*_-+=<>.?/" ++
        "ΑαΒβΓγΔδΕεΖζΗηΘθΙιΚκΛλΜμΝνΞξΟοΠπΡρΣσςΤτΥυΦφΧχΨψΩω" ++
        "₀₁₂₃₄₅₆₇₈₉"
      let allowedSet : Std.HashSet UInt32 := Std.HashSet.insertMany Std.HashSet.emptyWithCapacity (List.map Char.val allowedStr.toList)
      c.isAlphanum || allowedSet.contains c.val

def indicatorVariableName (name : Name) : CoreM String := do
  let smtName ← match veil.smt.translator.get (← getOptions) with
  | .leanAuto => getLeanAutoNameFor name.toString
  | .leanSmt => pure name.toString
  return smtName

open Lean Elab Command Term Meta Tactic in
def getQueryForGoal : TacticM String := withMainContext do
  let idents ← getPropsInContext
  let stx := ( ← `(Veil.SMT.sauto| sauto [$[$idents:ident],*])).raw
  let mv ← Tactic.getMainGoal
  let translatorToUse := veil.smt.translator.get (← getOptions)
  let cmdString ←
    match translatorToUse with
    | .leanAuto => Veil.SMT.prepareLeanAutoQuery mv (← Veil.SMT.parseAutoHints ⟨stx[1]⟩)
    | .leanSmt =>
      let (_map, hs) ← Smt.Tactic.elabHints ⟨stx[1]⟩
      Veil.SMT.prepareLeanSmtQuery mv hs.toList
  return cmdString

open Lean Elab Command Term Meta Tactic
/-- This performs the same simplifications as `fast_simplify_clause` on
the given expression and then passes it to the SMT translator.-/
def translateExprToSmt (expr: Expr) : TermElabM String := do
  let g ← mkFreshExprMVar expr
  let (cmdString, [_l]) ← Tactic.run g.mvarId! (do
    Veil.tryGoal $ Veil.run `(tactic|(unhygienic intros); fast_simplify_clause)
    for mvarId in (← Tactic.getGoals) do
      liftM <| mvarId.refl <|> mvarId.inferInstance <|> pure ()
    Tactic.pruneSolvedGoals
    let cmdString ← getQueryForGoal
    return cmdString
   ) | throwError "[translateExprToSmt] expected exactly one goal after simplification"
  return cmdString

def querySolverWithIndicators (goalQuery : String) (withTimeout : Nat) (checks: Array (Array (Name × Expr))) (forceSolver : Option SmtSolver := none)
  : MetaM (List ((List Name) × SmtResult)) := do
  withTraceNode `veil.smt.perf.query (fun _ => return "querySolverWithIndicators") do
  let opts ← getOptions
    let solverName :=
      match forceSolver with
      | some s => s
      | none => veil.smt.solver.get opts
    trace[veil.smt.debug] "solver: {solverName}"
  let solver ← Veil.SMT.createSolver solverName withTimeout
  Veil.SMT.emitCommandStr solver s!"{goalQuery}\n"
  let mut ret := []
  let indicatorNames := (checks.map (fun arr => arr.map (fun (_, ind) => ind.constName!))).flatten
  for check in checks do
    trace[veil.smt.debug] "Now running solver"
    let variablesInCheck := (check.map (fun (act, _) => act)).toList
    let indicatorsInCheck := check.map (fun (_, ind) => ind.constName!)
    let checkName := indicatorsInCheck.foldl (fun acc new => s!"{mkPrintableName new}_{acc}") "_checkSatIndicator_"
    let expression ← indicatorNames.foldlM (fun acc new => do
      if indicatorsInCheck.contains new then
        return s!"{← indicatorVariableName new} {acc}"
      else return s!"(not {← indicatorVariableName new}) {acc}") ""
    try
      Veil.SMT.emitCommandStr solver s!"(define-fun {checkName} () Bool (and {expression}))\n"
      Veil.SMT.emitCommandStr solver s!"(check-sat-assuming ({checkName}))\n"
      let stdout ← Handle.readLineSkip solver.stdout
      let (checkSatResponse, _) ← Auto.Solver.SMT.getSexp stdout
      let checkSatResponse: SmtResult := match checkSatResponse with
        | .atom (.symb "sat") => SmtResult.Sat none
        | .atom (.symb "unsat") => SmtResult.Unsat
        | .atom (.symb "unknown") => SmtResult.Unknown ""
        | e => SmtResult.Failure s!"{e}"
      trace[veil.smt.debug] "Test result: {checkSatResponse}"
      ret := ret ++ [((variablesInCheck, checkSatResponse))]
    catch e =>
      let exMsg ← e.toMessageData.toString
      let stderr ← solver.stderr.readToEnd
      let stderr := if stderr.isEmpty then "" else s!"{stderr.trim}"
      trace[veil.smt.debug] "exception: {exMsg} | stderr: {stderr}"
      ret := ret ++ [((variablesInCheck, .Failure s!"{stderr}"))]

  trace[veil.smt.debug] "Results for all actions and invariants: {ret}"
  solver.kill
  return ret
