#!/usr/bin/env python3
"""
Parse Firefox Profiler JSON files generated by Lean's trace.profiler.

Usage:
    ./scripts/parse-profile.py <profile.json> [--filter veil.perf]
    ./scripts/parse-profile.py <profile.json> --tree
    ./scripts/parse-profile.py <profile.json> --strings

The Firefox Profiler format uses stack sampling:
- stringArray: Array of all strings (labels, function names, etc.)
- funcTable.name: Function name indices into stringArray
- stackTable: Stack frames forming a tree (frame, prefix)
- samples: Stack samples with timing (stack index, time, weight)

See: https://github.com/firefox-devtools/profiler/blob/main/docs-developer/gecko-profile-format.md
"""

import json
import sys
import argparse
from collections import defaultdict


def load_profile(path: str) -> dict:
    """Load a Firefox Profiler JSON file."""
    with open(path, 'r') as f:
        return json.load(f)


def build_stack_tree(thread: dict) -> dict:
    """Build a tree structure from stackTable.

    Returns dict mapping stack_idx -> (func_name, parent_stack_idx)
    """
    strings = thread.get('stringArray', [])
    func_table = thread.get('funcTable', {})
    func_names = func_table.get('name', [])
    frame_table = thread.get('frameTable', {})
    frame_funcs = frame_table.get('func', [])
    stack_table = thread.get('stackTable', {})
    stack_frames = stack_table.get('frame', [])
    stack_prefixes = stack_table.get('prefix', [])

    def get_func_name(stack_idx):
        if stack_idx is None or stack_idx >= len(stack_frames):
            return None
        frame_idx = stack_frames[stack_idx]
        if frame_idx >= len(frame_funcs):
            return None
        func_idx = frame_funcs[frame_idx]
        if func_idx >= len(func_names):
            return None
        name_idx = func_names[func_idx]
        if name_idx >= len(strings):
            return f"<{name_idx}>"
        return strings[name_idx]

    tree = {}
    for i in range(len(stack_frames)):
        name = get_func_name(i)
        prefix = stack_prefixes[i] if i < len(stack_prefixes) else None
        tree[i] = (name, prefix)

    return tree


def get_stack_trace(tree: dict, stack_idx: int) -> list:
    """Get full stack trace from leaf to root."""
    trace = []
    while stack_idx is not None:
        if stack_idx not in tree:
            break
        name, parent = tree[stack_idx]
        if name:
            trace.append(name)
        stack_idx = parent
    return trace  # leaf to root order


def analyze_samples(thread: dict, filter_prefix: str = None) -> dict:
    """Analyze stack samples to compute time per function.

    Returns dict: func_name -> {"self_time": ms, "total_time": ms, "count": n}
    """
    tree = build_stack_tree(thread)
    samples = thread.get('samples', {})
    stacks = samples.get('stack', [])
    times = samples.get('time', [])
    weights = samples.get('weight', [])

    stats = defaultdict(lambda: {"self_time": 0, "total_time": 0, "count": 0})

    for i, stack_idx in enumerate(stacks):
        if stack_idx is None:
            continue

        weight = weights[i] if i < len(weights) else 1
        trace = get_stack_trace(tree, stack_idx)

        if not trace:
            continue

        # Apply filter if specified
        if filter_prefix:
            trace = [f for f in trace if filter_prefix in f]
            if not trace:
                continue

        # Self time goes to the leaf (first in trace)
        leaf = trace[0]
        stats[leaf]["self_time"] += weight
        stats[leaf]["count"] += 1

        # Total time goes to all functions in stack
        seen = set()
        for func in trace:
            if func not in seen:
                stats[func]["total_time"] += weight
                seen.add(func)

    return dict(stats)


def print_summary(stats: dict, sort_by: str = "total_time"):
    """Print function timing summary."""
    if not stats:
        print("No matching functions found.")
        return

    sorted_stats = sorted(stats.items(), key=lambda x: x[1][sort_by], reverse=True)

    print(f"\n{'Function':<70} {'Self (ms)':>10} {'Total (ms)':>10} {'Count':>8}")
    print("-" * 100)

    for name, data in sorted_stats[:40]:
        # Truncate long names
        display_name = name if len(name) <= 68 else name[:65] + "..."
        print(f"{display_name:<70} {data['self_time']:>10.1f} {data['total_time']:>10.1f} {data['count']:>8}")


def print_tree_view(thread: dict, filter_prefix: str = None):
    """Print a tree view of the call hierarchy."""
    tree = build_stack_tree(thread)
    samples = thread.get('samples', {})
    stacks = samples.get('stack', [])
    weights = samples.get('weight', [])

    # Build call tree with timing
    call_tree = defaultdict(lambda: {"children": defaultdict(int), "self_time": 0})

    for i, stack_idx in enumerate(stacks):
        if stack_idx is None:
            continue

        weight = weights[i] if i < len(weights) else 1
        trace = get_stack_trace(tree, stack_idx)

        if filter_prefix:
            # Only show filtered functions but keep hierarchy
            trace = [f for f in trace if filter_prefix in f]

        if not trace:
            continue

        # Record self time at leaf
        call_tree[trace[0]]["self_time"] += weight

        # Record parent-child relationships (trace is leaf->root)
        for j in range(len(trace) - 1):
            child = trace[j]
            parent = trace[j + 1]
            call_tree[parent]["children"][child] += weight

    # Print tree starting from roots (functions with no callers in filtered set)
    all_children = set()
    for data in call_tree.values():
        all_children.update(data["children"].keys())

    roots = [f for f in call_tree.keys() if f not in all_children]

    def print_node(name, indent=0, visited=None):
        if visited is None:
            visited = set()
        if name in visited:
            return
        visited.add(name)

        data = call_tree[name]
        total = data["self_time"] + sum(data["children"].values())
        prefix = "  " * indent
        display_name = name if len(name) + indent * 2 <= 68 else name[:65 - indent * 2] + "..."
        print(f"{prefix}{display_name:<{70-indent*2}} {total:>10.1f}")

        # Sort children by time
        sorted_children = sorted(data["children"].items(), key=lambda x: x[1], reverse=True)
        for child, _ in sorted_children[:10]:  # Limit children shown
            print_node(child, indent + 1, visited.copy())

    print(f"\n{'Call Tree':<70} {'Time (ms)':>10}")
    print("-" * 82)

    sorted_roots = sorted(roots, key=lambda r: call_tree[r]["self_time"] + sum(call_tree[r]["children"].values()), reverse=True)
    for root in sorted_roots[:10]:
        print_node(root)
        print()


def main():
    parser = argparse.ArgumentParser(
        description='Parse Firefox Profiler JSON files from Lean profiler'
    )
    parser.add_argument('profile', help='Path to profile.json file')
    parser.add_argument('--filter', '-f', default=None,
                        help='Filter functions by prefix (e.g., "veil.perf")')
    parser.add_argument('--tree', '-t', action='store_true',
                        help='Show hierarchical call tree view')
    parser.add_argument('--strings', '-s', action='store_true',
                        help='List all Veil-related strings')
    parser.add_argument('--all', '-a', action='store_true',
                        help='Show all functions (not just Veil)')
    args = parser.parse_args()

    profile = load_profile(args.profile)

    print(f"Profile: {args.profile}")
    meta = profile.get('meta', {})
    print(f"Version: {meta.get('version', 'unknown')}, Interval: {meta.get('interval', 'unknown')}ms")

    if args.strings:
        if 'threads' in profile and profile['threads']:
            thread = profile['threads'][0]
            strings = thread.get('stringArray', [])
            veil_strings = sorted([s for s in strings if 'veil' in str(s).lower()])
            print(f"\nVeil-related strings ({len(veil_strings)}):")
            for s in veil_strings:
                print(f"  {s}")
        return

    # Default filter to veil unless --all specified
    filter_prefix = args.filter
    if filter_prefix is None and not args.all:
        filter_prefix = "veil"

    # Analyze main thread (usually first)
    if 'threads' in profile and profile['threads']:
        main_thread = profile['threads'][0]
        thread_name = main_thread.get('name', 'Main')
        print(f"Analyzing thread: {thread_name}")

        if args.tree:
            print_tree_view(main_thread, filter_prefix)
        else:
            stats = analyze_samples(main_thread, filter_prefix)
            print_summary(stats)


if __name__ == '__main__':
    main()
