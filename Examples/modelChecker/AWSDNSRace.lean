import Veil
import Veil.Core.Tools.Checker.Concrete.Main
veil module AwsDNSRace
-- ------------------------------ MODULE AwsDNSRace ------------------------------
-- EXTENDS Naturals, Sequences, TLC

-- type ENACTORS
-- ENACTORS = {e1, e2}
-- CONSTANTS
--     ENACTORS,             \* set of concurrent Enactors
enum ENACTORS = {e1, e2, e3}

-- VARIABLES
--     current_plan,         \* currently active Route53 plan
individual current_plan : Nat
--     latest_plan,          \* last plan generated by the Planner
individual latest_plan : Nat
--     highest_plan_applied, \* highest version ever applied
individual highest_plan_applied : Nat
--     plan_deleted,         \* set of deleted plans
individual plan_deleted : List Nat
--     plan_channel,         \* queue of plans awaiting enactment
individual plan_channel : List Nat
--     enactor_processing,   \* which plan each Enactor is processing
function enactor_processing : ENACTORS → Nat
--     enactor_pc            \* Enactor program counter
function enactor_pc : ENACTORS → Nat

-- CONSTANTS
--     MAX_PLAN              \* maximum number of plans (bounded model checking)
immutable individual max_plan : Nat
--     PLAN_AGE_THRESHOLD,   \* number of plans after which a plan can be delete
immutable individual plan_age_threshold : Nat
/- Encode the finite domain used in this model. -/
immutable individual domain : List Nat

#gen_state

-- Init ==
--     /\ current_plan = 0
--     /\ latest_plan = 0
--     /\ highest_plan_applied = 0
--     /\ plan_deleted = [i \in 1..MAX_PLAN |-> FALSE]
--     /\ plan_channel = << >>
--     /\ enactor_processing = [e \in ENACTORS |-> 0]
--     /\ enactor_pc = [e \in ENACTORS |-> 0]
after_init {
  current_plan  := 0
  latest_plan := 0
  highest_plan_applied := 0
  -- plan_deleted I T := T == false
  plan_deleted := []
  plan_channel := []
  enactor_processing E := 0
  enactor_pc E := 0
}
-- (***************************************************************************)
-- (* Planner behavior                                                        *)
-- (***************************************************************************)

-- PlannerStep ==
--     /\ latest_plan < MAX_PLAN
--     /\ latest_plan' = latest_plan + 1
--     /\ plan_channel' = Append(plan_channel, latest_plan + 1)
--     /\ UNCHANGED <<current_plan, highest_plan_applied, plan_deleted,
--                    enactor_processing, enactor_pc>>

-- procedure succ (n : seq_t) {
--   let k :| next n k
--   return k
-- }

action _PlannerStep {
  require latest_plan < max_plan
  let latest_plan_plus_1 := latest_plan + 1
  latest_plan := latest_plan_plus_1
  plan_channel := plan_channel ++ [latest_plan_plus_1]
}
-- (***************************************************************************)
-- (* Enactor behavior                                                        *)
-- (***************************************************************************)

-- EnactorReceiveStep(self) ==
--   /\ plan_channel # << >>
--   /\ enactor_pc[self] = 0
--   /\ enactor_processing' =
--        [enactor_processing EXCEPT ![self] = Head(plan_channel)]
--   /\ enactor_pc' =
--        [enactor_pc EXCEPT ![self] = 1]
--   /\ plan_channel' = Tail(plan_channel)
--   /\ UNCHANGED <<current_plan, latest_plan,
--                  highest_plan_applied, plan_deleted>>
action _EnactorReceiveStep (self : ENACTORS) {
  require plan_channel ≠ []
  require enactor_pc self == 0
  enactor_processing self := plan_channel.head!
  enactor_pc self := 1
  plan_channel := plan_channel.tail
}


-- EnactorApplyStep(self) ==
--     /\ enactor_pc[self] = 1
--     /\ IF  ~plan_deleted[enactor_processing[self]]
--         THEN
--             /\ current_plan' = enactor_processing[self]
--             /\ highest_plan_applied' =
--                 IF enactor_processing[self] > highest_plan_applied
--                   THEN enactor_processing[self]
--                   ELSE highest_plan_applied
--             /\ enactor_pc' =
--                 [enactor_pc EXCEPT ![self] = 2]
--             /\ UNCHANGED <<latest_plan, plan_deleted,
--                            plan_channel, enactor_processing>>
--         ELSE
--             /\ enactor_processing' =
--                 [enactor_processing EXCEPT ![self] = 0]
--             /\ enactor_pc' =
--                 [enactor_pc EXCEPT ![self] = 0]
--             /\ UNCHANGED <<current_plan, latest_plan, highest_plan_applied,
--                            plan_deleted, plan_channel>>

action _EnactorApplyStep (self : ENACTORS) {
  require enactor_pc self == 1
  let enactor_processing_self := enactor_processing self
  if !(plan_deleted.contains enactor_processing_self) then
    current_plan := enactor_processing_self
    if highest_plan_applied < enactor_processing_self  then
      highest_plan_applied := enactor_processing_self
    enactor_pc self := 2
  else
    enactor_processing self := 0
    enactor_pc self := 0
}



-- EnactorCleanupStep(self) ==
--     /\ enactor_pc[self] = 2
--     /\ plan_deleted' = Cleanup(enactor_processing[self], plan_deleted)
--     /\ enactor_processing' =
--         [enactor_processing EXCEPT ![self] = 0]
--     /\ enactor_pc' =
--         [enactor_pc EXCEPT ![self] = 0]
--     /\ UNCHANGED <<current_plan, latest_plan,
--                    highest_plan_applied, plan_channel>>
-- procedure plus_threshold (my_plan : seq_t) {
--   let k :| next my_plan k
--   let m :| next k m
--   return m
-- }

-- Cleanup(my_plan, old) ==
--     [j \in 1..MAX_PLAN |->
--         IF (my_plan - j >= PLAN_AGE_THRESHOLD)
--            THEN TRUE
--            ELSE old[j]
--     ]
action _EnactorCleanupStep (self : ENACTORS) {
  require enactor_pc self == 2
  let my_plan := enactor_processing self
  let plan_deleted_updated := domain.filter (fun p => my_plan - p ≥ plan_age_threshold)
  plan_deleted := domain.filter (fun p => plan_deleted_updated.contains p ∨ plan_deleted.contains p)
  enactor_processing self := 0
  enactor_pc self := 0
}
-- (***************************************************************************)
-- (* Next-state relation                                                     *)
-- (***************************************************************************)
-- Next ==
--     \/ PlannerStep
--     \/ \E self \in ENACTORS : EnactorReceiveStep(self)
--     \/ \E self \in ENACTORS : EnactorApplyStep(self)
--     \/ \E self \in ENACTORS : EnactorCleanupStep(self)



-- (***************************************************************************)
-- (* Invariants                                                              *)
-- (***************************************************************************)

-- NeverDeleteActive ==
--     current_plan > 0 => ~plan_deleted[current_plan]
invariant [NeverDeleteActive]
  current_plan > 0 → ¬ (plan_deleted.contains current_plan)

-- (***************************************************************************)
-- (* Specification                                                          *)
-- (***************************************************************************)

-- Spec ==
--     Init /\ [][Next]_<<current_plan, latest_plan, highest_plan_applied,
--                         plan_deleted, plan_channel, enactor_processing, enactor_pc>>
#gen_spec
-- ============================== END MODULE AwsDNSRace ==============================
-- \* Example constants
-- \* MAX_PLAN == 5
-- \* PLAN_AGE_THRESHOLD == 2
-- \* NUM_ENACTORS == 2

-- #check_invariants
#gen_exec

-- #finitize_types ENACTORS
set_option trace.veil.debug true
#Concretize ENACTORS
deriving_BEqHashable_ConcreteState
deriving_toJson_for_state
deriving_DecidableProps_state

def view (st : StateConcrete) := hash st
def detect_prop : TheoryConcrete → StateConcrete → Bool := (fun ρ σ => NeverDeleteActive ρ σ)
def terminationC : TheoryConcrete → StateConcrete → Bool := (fun ρ σ => true)
def cfg : TheoryConcrete := {max_plan := 5, plan_age_threshold := 2, domain := [1, 2, 3, 4, 5]}

def modelCheckerResult' :=(runModelCheckerx initVeilMultiExecM nextVeilMultiExecM labelList (detect_prop) (terminationC) cfg view).snd
#time #eval modelCheckerResult'.seen.size
def statesJson : Lean.Json := Lean.toJson (recoverTrace initVeilMultiExecM nextVeilMultiExecM cfg (collectTrace' modelCheckerResult'))
#eval statesJson
open ProofWidgets
open scoped ProofWidgets.Jsx
#html <ModelCheckerView trace={statesJson} layout={"vertical"} />



end AwsDNSRace
