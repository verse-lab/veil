import Veil
import Veil.Core.Tools.Checker.Concrete.Main
veil module AwsDNSRace

-- ------------------------------ MODULE AwsDNSRace ------------------------------
-- EXTENDS Naturals, Sequences, TLC

-- type ENACTORS
-- ENACTORS = {e1, e2}
-- CONSTANTS
--     ENACTORS,             \* set of concurrent Enactors
enum ENACTORS = {e1, e2}


-- VARIABLES
--     current_plan,         \* currently active Route53 plan
individual current_plan : (Fin 6)
--     latest_plan,          \* last plan generated by the Planner
individual latest_plan : (Fin 6)
--     highest_plan_applied, \* highest version ever applied
individual highest_plan_applied : Nat
--     plan_deleted,         \* set of deleted plans
-- individual plan_deleted : List Nat
relation plan_deleted : (Fin 6) → Bool → Bool
--     plan_channel,         \* queue of plans awaiting enactment
individual plan_channel : List (Fin 6)
--     enactor_processing,   \* which plan each Enactor is processing
function enactor_processing : ENACTORS → (Fin 6)
--     enactor_pc            \* Enactor program counter
function enactor_pc : ENACTORS → Nat

-- CONSTANTS
--     MAX_PLAN              \* maximum number of plans (bounded model checking)
immutable individual max_plan : (Fin 6)
--     PLAN_AGE_THRESHOLD,   \* number of plans after which a plan can be delete
immutable individual plan_age_threshold : (Fin 6)
/- Encode the finite domain used in this model. -/
-- immutable individual domain : List Nat

#gen_state

-- Init ==
--     /\ current_plan = 0
--     /\ latest_plan = 0
--     /\ highest_plan_applied = 0
--     /\ plan_deleted = [i \in 1..MAX_PLAN |-> FALSE]
--     /\ plan_channel = << >>
--     /\ enactor_processing = [e \in ENACTORS |-> 0]
--     /\ enactor_pc = [e \in ENACTORS |-> 0]
after_init {
  current_plan  := (0 : (Fin 6))
  latest_plan := (0 : (Fin 6))
  highest_plan_applied := 0
  plan_deleted N F := F == false
  plan_channel := ([] : (List ((Fin 6))))
  enactor_processing E := (0 : (Fin 6))
  enactor_pc E := 0
}
-- (***************************************************************************)
-- (* Planner behavior                                                        *)
-- (***************************************************************************)


-- PlannerStep ==
--     /\ latest_plan < MAX_PLAN
--     /\ latest_plan' = latest_plan + 1
--     /\ plan_channel' = Append(plan_channel, latest_plan + 1)
--     /\ UNCHANGED <<current_plan, highest_plan_applied, plan_deleted,
--                    enactor_processing, enactor_pc>>
action PlannerStep {
  require latest_plan < max_plan
  let latest_plan_plus_1 := latest_plan + 1
  assert latest_plan_plus_1.val ≤ max_plan
  latest_plan := latest_plan_plus_1
  plan_channel := plan_channel ++ [latest_plan_plus_1]
}
-- (***************************************************************************)
-- (* Enactor behavior                                                        *)
-- (***************************************************************************)

-- EnactorReceiveStep(self) ==
--   /\ plan_channel # << >>
--   /\ enactor_pc[self] = 0
--   /\ enactor_processing' =
--        [enactor_processing EXCEPT ![self] = Head(plan_channel)]
--   /\ enactor_pc' =
--        [enactor_pc EXCEPT ![self] = 1]
--   /\ plan_channel' = Tail(plan_channel)
--   /\ UNCHANGED <<current_plan, latest_plan,
--                  highest_plan_applied, plan_deleted>>
action EnactorReceiveStep (self : ENACTORS) {
  require plan_channel ≠ []
  require enactor_pc self == 0
  enactor_processing self := plan_channel.head!
  enactor_pc self := 1
  plan_channel := plan_channel.tail
}


-- EnactorApplyStep(self) ==
--     /\ enactor_pc[self] = 1
--     /\ IF  ~plan_deleted[enactor_processing[self]]
--         THEN
--             /\ current_plan' = enactor_processing[self]
--             /\ highest_plan_applied' =
--                 IF enactor_processing[self] > highest_plan_applied
--                   THEN enactor_processing[self]
--                   ELSE highest_plan_applied
--             /\ enactor_pc' =
--                 [enactor_pc EXCEPT ![self] = 2]
--             /\ UNCHANGED <<latest_plan, plan_deleted,
--                            plan_channel, enactor_processing>>
--         ELSE
--             /\ enactor_processing' =
--                 [enactor_processing EXCEPT ![self] = 0]
--             /\ enactor_pc' =
--                 [enactor_pc EXCEPT ![self] = 0]
--             /\ UNCHANGED <<current_plan, latest_plan, highest_plan_applied,
--                            plan_deleted, plan_channel>>

action EnactorApplyStep (self : ENACTORS) {
  require enactor_pc self == 1
  let enactor_processing_self := enactor_processing self
  -- if !(plan_deleted.contains enactor_processing_self) then
  if plan_deleted enactor_processing_self false then
    current_plan := enactor_processing_self
    if highest_plan_applied < enactor_processing_self.val then
      highest_plan_applied := enactor_processing_self.val
    enactor_pc self := 2
  else
    enactor_processing self := (0 : Fin 6)
    enactor_pc self := 0
}

-- Cleanup(my_plan, old) ==
--     [j \in 1..MAX_PLAN |->
--         IF (my_plan - j >= PLAN_AGE_THRESHOLD)
--            THEN TRUE
--            ELSE old[j]
--     ]

-- EnactorCleanupStep(self) ==
--     /\ enactor_pc[self] = 2
--     /\ plan_deleted' = Cleanup(enactor_processing[self], plan_deleted)
--     /\ enactor_processing' =
--         [enactor_processing EXCEPT ![self] = 0]
--     /\ enactor_pc' =
--         [enactor_pc EXCEPT ![self] = 0]
--     /\ UNCHANGED <<current_plan, latest_plan,
--                    highest_plan_applied, plan_channel>>

action EnactorCleanupStep (self : ENACTORS) {
  require enactor_pc self == 2
  let my_plan := enactor_processing self
  /- Note: we should add guard condition `my_plan ≥ N` for this assignment statement.
  Besides, as the domain is `[i \in 1..MAX_PLAN]`, we can add condition `N > 0`.
  -/
  plan_deleted N F := if (N ≠ 0) ∧ (my_plan ≥  N) ∧ (my_plan - N).val ≥ plan_age_threshold then (F == true) else plan_deleted N F
  -- my_plan - N ≥ plan_age_threshold
  -- let plan_deleted_updated := domain.filter (fun p => my_plan - p ≥ plan_age_threshold)
  -- plan_deleted := domain.filter (fun p => plan_deleted_updated.contains p ∨ plan_deleted.contains p)
  enactor_processing self := (0 : Fin 6)
  enactor_pc self := 0
}



-- NeverDeleteActive ==
--     current_plan > 0 => ~plan_deleted[current_plan]
invariant [NeverDeleteActive] current_plan > 0 → ¬(plan_deleted current_plan true)
invariant [uniqueDelete] plan_deleted C F ∧ plan_deleted C T → F = T



-- Spec ==
--     Init /\ [][Next]_<<current_plan, latest_plan, highest_plan_applied,
--                         plan_deleted, plan_channel, enactor_processing, enactor_pc>>
#gen_spec

-- #check_invariants
#gen_exec

#finitizeTypes ENACTORS
#eval labelList


def view (st : StateConcrete) := hash st
def detect_prop : TheoryConcrete → StateConcrete → Bool := (fun ρ σ => NeverDeleteActive ρ σ)
def terminationC : TheoryConcrete → StateConcrete → Bool := (fun ρ σ => true)
def cfg : TheoryConcrete := {max_plan := 5, plan_age_threshold := 2}


def modelCheckerResult' :=(runModelCheckerx initVeilMultiExecM nextVeilMultiExecM labelList (detect_prop) (terminationC) cfg view).snd
-- #time #eval modelCheckerResult'.seen.size
def statesJson : Lean.Json := Lean.toJson (recoverTrace initVeilMultiExecM nextVeilMultiExecM cfg (collectTrace' modelCheckerResult'))
#eval statesJson
open ProofWidgets
open scoped ProofWidgets.Jsx
#html <ModelCheckerView trace={statesJson} layout={"vertical"} />

end AwsDNSRace
