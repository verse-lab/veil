import Veil

/- https://muratbuffalo.blogspot.com/2025/11/tla-modeling-of-aws-outage-dns-race.html?m=1 -/

veil module AwsDNSRace

enum ENACTORS = {e1, e2}

-- VARIABLES
--     current_plan,         \* currently active Route53 plan
individual current_plan : (Fin 6)
--     latest_plan,          \* last plan generated by the Planner
individual latest_plan : (Fin 6)
--     highest_plan_applied, \* highest version ever applied
individual highest_plan_applied : Nat
--     plan_deleted,         \* set of deleted plans
-- individual plan_deleted : List Nat
relation plan_deleted : (Fin 6) → Bool → Bool
--     plan_channel,         \* queue of plans awaiting enactment
individual plan_channel : List (Fin 6)
--     enactor_processing,   \* which plan each Enactor is processing
function enactor_processing : ENACTORS → (Fin 6)
--     enactor_pc            \* Enactor program counter
function enactor_pc : ENACTORS → Nat

-- CONSTANTS
--     MAX_PLAN              \* maximum number of plans (bounded model checking)
immutable individual max_plan : (Fin 6)
--     PLAN_AGE_THRESHOLD,   \* number of plans after which a plan can be delete
immutable individual plan_age_threshold : (Fin 6)

#gen_state

after_init {
  current_plan  := (0 : (Fin 6))
  latest_plan := (0 : (Fin 6))
  highest_plan_applied := 0
  plan_deleted N F := F == false
  plan_channel := ([] : (List ((Fin 6))))
  enactor_processing E := (0 : (Fin 6))
  enactor_pc E := 0
}


action PlannerStep {
  require latest_plan < max_plan
  let latest_plan_plus_1 := latest_plan + 1
  assert latest_plan_plus_1.val ≤ max_plan
  latest_plan := latest_plan_plus_1
  plan_channel := plan_channel ++ [latest_plan_plus_1]
}

action EnactorReceiveStep (self : ENACTORS) {
  require plan_channel ≠ []
  require enactor_pc self == 0
  enactor_processing self := plan_channel.head!
  enactor_pc self := 1
  plan_channel := plan_channel.tail
}


action EnactorApplyStep (self : ENACTORS) {
  require enactor_pc self == 1
  let enactor_processing_self := enactor_processing self
  -- if !(plan_deleted.contains enactor_processing_self) then
  if plan_deleted enactor_processing_self false then
    current_plan := enactor_processing_self
    if highest_plan_applied < enactor_processing_self.val then
      highest_plan_applied := enactor_processing_self.val
    enactor_pc self := 2
  else
    enactor_processing self := (0 : Fin 6)
    enactor_pc self := 0
}

action EnactorCleanupStep (self : ENACTORS) {
  require enactor_pc self == 2
  let my_plan := enactor_processing self
  /- Note: we should add guard condition `my_plan ≥ N` for this assignment statement.
  Besides, as the domain is `[i \in 1..MAX_PLAN]`, we can add condition `N > 0`.
  -/
  plan_deleted N F := if (N ≠ 0) ∧ (my_plan ≥  N) ∧ (my_plan - N).val ≥ plan_age_threshold then (F == true) else plan_deleted N F
  enactor_processing self := (0 : Fin 6)
  enactor_pc self := 0
}

invariant [NeverDeleteActive] current_plan > 0 → ¬(plan_deleted current_plan true)
invariant [uniqueDelete] plan_deleted C F ∧ plan_deleted C T → F = T


#time #gen_spec

set_option veil.violationIsError false in
#model_check {}{ max_plan := 5, plan_age_threshold := 2 }

end AwsDNSRace
